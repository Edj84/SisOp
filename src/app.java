import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;

/*
 Definição:
Ler de um arquivo as seguintes informações, nesta ordem: 
número de processos, DONE
tamanho de fatia de tempo, DONE 
para cada processo:, DONE
	tempo de chegada, 
	tempo de execução, 
	prioridade (1 até 9 - prioridade 1 é a melhor) e 
	tempos de acesso a operações de E/S (tempo correspondente a sua execução).

Imprimir os tempos médios de resposta e espera para o algoritmo Round Robin com prioridade.

Além disto imprimir um gráfico (texto) mostrando como os processo foram executados.
 
Considerar uma unidade de tempo para troca de contexto (representado abaixo como C). 
Tempo começa em 1. - DONE
Processos iniciam com 1. 
Processo chega no tempo x e pode começar a executar (respeitando o algoritmo de escalonamento) no tempo x+2 (1 unidade para troca de contexto).
Tempo que leva para fazer uma operação de entrada e saída: use valor constante igual a 4. 

Exemplo de arquivo de entrada:

5
3
3 10 2
5 12 1
9 15 2
11 15 1
12 8 5 2

Exemplo de gráfico a ser exibido para o exemplo acima:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
- - - C 1 C 2 2 2  C  2  2  2  C  4  4  4  C 2 2 2 C 4 4 4 C 2 2 2 C 4 4 4 C 4 4 4 C 4 4 4 C 1 1 C 3 3 3 C111C333C111C333C1C333C333C55C---C5C555C55

Entregar o código fonte e um arquivo com a descrição do trabalho em no máximo 4 páginas. Utilizar um formato de artigo científico, da ACM, IEEE ou SBC.
 */


public class app {
	
	private static RoundRobin rr;
	private static ArrayList<Job> jobs;
	private static CPU cpu;
	private static int numJobs;
	private static int time;
				
	public static void main(String[ ] args) {
		
		//Leitura da time slice e dos jobs a partir do arquivo
		read();		
		System.out.println("Li " + jobs.size() + " jobs");		
		
		//inicia a simulação
		simulate();
	
	}
		
	private static void simulate() {
		
		time = 1;
		
		cpu = new CPU();
		
		//Executa enquanto o número de processos na fila de concluídos for menor do que o de processos lidos do arquivo
		
		while(!rr.JobsDone(numJobs)) {
			
			//Verifica se algum processo chegou no tempo atual
			checkJobsArrived();
			
			//Verifica se algum processo está usando a CPU
			if(!getCpuStatus()) {							
				
				//CPU ocupada. Verifica se o processo que está usando a CPU vai ser preemptado por outro de melhor prioridade
				if(checkPreemption()) {
					//Caso haja preempção, muda o processo que está usando a CPU	
					removeJob(JobStatus.READY);
					getNewJob();
				}
				
				//Já que não houve preempção, verifica se o processo atual no processador terminou sua fatia de tempo
				else if(!rr.checkHasTimeLeft()) {
						//Retira o processo da CPU caso a fatia de tempo tenha se esgotado
						removeJob(JobStatus.READY);
						getNewJob();
				}
				
					//Processo não foi preemptado e ainda tem tem tempo na CPU. Verifica se ele vai fazer operação de IO
					else if(cpu.getJob().checkIO(time)) {
							removeJob(JobStatus.BLOCKED);
							getNewJob();						
					}
						//Processo "sobreviveu" na CPU (não foi preemptado, ainda tem tem tempo e não fez operação de IO).
						//Vai executar por mais uma unidade de tempo
						else {
							runJob();
							checkJobDone();
						}
			}
			
			//CPU livre. Tenta obter um novo processo pronto para executar
			else getNewJob();
			
			time++;
		}
		
	}

	private static void checkJobDone() {
		Job currentJob = cpu.getJob();
		if(currentJob.getReceivedTime() == currentJob.getRunTime())
			removeJob(JobStatus.DONE);		
	}
	
	private static void removeJob(JobStatus status) {
		Job jobRemoved = cpu.removeJob();
		jobRemoved.setStatus(status);
		rr.receiveJob(jobRemoved);		
	}

	private static void checkJobsArrived() {
			
		for(int i = 0; i < jobs.size(); i++) {
		
			if(jobs.get(i).getRunTime() == time)	
				//Retira o job a executar da lista de jobs lidos do arquivo e o envia para o escalonador
				rr.receiveJob(jobs.remove(i));
		}		
	}	
	
	private static boolean getCpuStatus() {
		if(cpu.getJob() == null) {
			//CPU sem processo
			System.out.println(" - ");
			return false;
		}
		return true;
	}

	private static boolean checkPreemption() {
		Job currentJob = cpu.getJob();
		int currentPriority = currentJob.getPriority();
		boolean preempt = false;
		
		//Processo com prioridade 1 não pode ser preemptado
		if(currentPriority == 1)
			return false;
		
		//Verifica se as filas de prioridades menores do que a do processo atual contém um job pronto para ser executado
		for(int i = 1; i < currentPriority && !preempt; i++)
			preempt = rr.checkReadyQueue(i);
			
		return preempt;	
	}
		
	private static void getNewJob() {
		cpu.setNewJob(rr.pickNextJob());		
	}
	
	private static void runJob() {
		cpu.runJob();
		rr.decrementTimeLeft();		
	}
		
	private static void read() {
		
		ArrayList<Job> jobs = new ArrayList<Job>();		
		File file = new File("jobs.txt");
		
		try {
			Scanner scan = new Scanner(file);
			
			ArrayList<String> jobsRead = new ArrayList<String>();
			
			numJobs = scan.nextInt();
			
			//Instancia Round Robin, informando o valor da fatia de tempo
			rr = new RoundRobin(scan.nextInt());
			
			scan.nextLine();
			
			//Lê os dados dos processos
			for(int i = 0; i < numJobs; i++) {
				String line = scan.nextLine();				
				jobsRead.add(line);
				System.out.println("Leitura: " + line );
			}			
			
			scan.close();
			
			//Aciona o método estático que vai instanciar os jobs e popular o ArrayList que os armazena
			populate(jobsRead);			
			
		}		
		catch (FileNotFoundException e) {
			e.printStackTrace();
		}		
		
	}
	
	//Instancia os jobs conforme os dados lidos do arquivo
	private static void populate(ArrayList<String> jobsRead) {
		
		Scanner scan;
		Job job;
		int arrivalTime, runTime, priority;
		ArrayList<Integer> IO;
		jobs = new ArrayList<Job>();
		
		for(String j : jobsRead) {
			scan = new Scanner(j);
			arrivalTime = scan.nextInt(); 
			runTime = scan.nextInt();
			priority = scan.nextInt();
			IO = new ArrayList<Integer>();
			
			while(scan.hasNextInt()) {
				IO.add(scan.nextInt());
			}
			
			jobs.add(new Job(arrivalTime, runTime, priority, IO));
		}
		
	}	
}